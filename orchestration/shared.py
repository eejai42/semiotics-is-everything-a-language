#!/usr/bin/env python3
"""
Shared functions for ERB language candidate generators.
All inject-into-*.py scripts use these common utilities.
"""

import json
import os
from pathlib import Path
from datetime import datetime


def get_rulebook_path():
    """Get the path to the effortless-rulebook.json file.

    Scripts run from /language-candidates/{candidate}/ so the rulebook
    is at ../../effortless-rulebook/effortless-rulebook.json
    """
    return Path("../../effortless-rulebook/effortless-rulebook.json")


def load_rulebook():
    """Load and parse the effortless-rulebook.json file."""
    rulebook_path = get_rulebook_path()

    if not rulebook_path.exists():
        raise FileNotFoundError(f"Rulebook not found at {rulebook_path}")

    with open(rulebook_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def ensure_output_folder():
    """Ensure the current working directory exists (it should, since we run from there)."""
    cwd = Path.cwd()
    cwd.mkdir(parents=True, exist_ok=True)
    return cwd


def write_readme(candidate_name, description=None, technology=None):
    """Write a placeholder README.md for the language candidate.

    Args:
        candidate_name: Name of the target language/format (e.g., 'python', 'owl')
        description: Optional description, defaults to a placeholder message
        technology: Optional technology section explaining the format/language
    """
    output_folder = ensure_output_folder()
    readme_path = output_folder / "README.md"

    if description is None:
        description = f"Placeholder for {candidate_name} generation from the Effortless Rulebook."

    # Build technology section if provided
    technology_section = ""
    if technology:
        technology_section = f"\n## Technology\n\n{technology}\n"

    content = f"""# {candidate_name.title()} Language Candidate

{description}
{technology_section}
## Status

This is a placeholder generated by the ERB orchestration system.

## Source

Generated from: `effortless-rulebook/effortless-rulebook.json`

## Generated

{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""

    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write(content)

    print(f"Created {readme_path}")
    return readme_path


def get_candidate_name_from_cwd():
    """Extract the candidate name from the current working directory.

    Assumes we're running from /language-candidates/{candidate}/
    """
    return Path.cwd().name
