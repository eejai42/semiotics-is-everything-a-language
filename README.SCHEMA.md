# Effortless Rulebook

### Generated from:

> This builds ssotme tools including those that are disabled which regenerates this file.

```
$ cd ./docs
$ ssotme -build -id
```


> CMCC rulebook generated directly from Airtable base.

**Model ID:** `appC8XTj95lubn6hz`

---

## Formal Arguments

The following logical argument establishes that "language" can be formalized as a computable classification, and demonstrates that not everything qualifies as a language under this definition.

### NEIAL-001: Definition (Motivation)

**Argument:** LanguageCanBeFormalized

> To avoid the slogan 'Everything is a language', treat 'language' as a typed construct defined by testable properties (syntax, parsing, linear decoding pressure, and descriptor-role).




*Note: This keeps 'can be interpreted' separate from 'is a language system'.*

---
### NEIAL-002: Definition (PredicateSet)

**Argument:** LanguageCanBeFormalized

> Use the repo predicates: HasSyntax, RequiresParsing, HasLinearDecodingPressure, StableOntologyReference (spelled IsOngologyDescriptor in the dataset), plus auxiliary checks like CanBeHeld and HasIdentity.

**Formalization:**
```
Predicates: Syntax(x), Parse(x), SerializeMeaning(x), OntDesc(x), Tangible(x)
```



*Note: We preserve the dataset's field name even when misspelled to match the generated schema.*

---
### NEIAL-003: Definition (Definition)

**Argument:** LanguageCanBeFormalized

> Operational definition: an item x counts as a Language if it has syntax, requires parsing, serializes meaning, and functions as an ontology/descriptor system.

**Formalization:**
```
Language(x) := HasSyntax(x) ∧ RequiresParsing(x) ∧ HasLinearDecodingPressure(x) ∧ StableOntologyReference(x)
```



*Note: This is a deliberately 'strong' definition: it matches formal languages and many natural language representations.*

---
### NEIAL-004: Premise (Witness)

**Argument:** LanguageCanBeFormalized

> There exists at least one clear witness that satisfies the operational definition: English.

**Formalization:**
```
∃x (x=English ∧ Language(x))
```

**Related Candidate:** English

**Evidence:** `HasSyntax=True; RequiresParsing=True; HasLinearDecodingPressure=True; IsOngologyDescriptor=True; CanBeHeld=False; HasIdentity=False; DistanceFromConcept=2; Category=Natural Language`

*Note: If any predicate is false in your current dataset for this witness, adjust the candidate record or relax the definition.*

---
### NEIAL-005: Premise (Witness)

**Argument:** LanguageCanBeFormalized

> There exists at least one clear witness that satisfies the operational definition: Python.

**Formalization:**
```
∃x (x=Python ∧ Language(x))
```

**Related Candidate:** Python

**Evidence:** `HasSyntax=True; RequiresParsing=True; HasLinearDecodingPressure=True; IsOngologyDescriptor=True; CanBeHeld=False; HasIdentity=False; DistanceFromConcept=2; Category=Formal Language`

*Note: If any predicate is false in your current dataset for this witness, adjust the candidate record or relax the definition.*

---
### NEIAL-006: Conclusion (Conclusion)

**Argument:** LanguageCanBeFormalized

> Therefore, 'language' can be formalized as a computable classification boundary over explicit predicates.

**Formalization:**
```
(Definition ∧ Witnesses) ⇒ Formalizable(Language)
```



*Note: This is the concession: language is formalizable (at least operationally).*

---
### NEIAL-007: Premise (Entailment)

**Argument:** NotEverythingIsALanguage

> If Language(x) is defined by necessary conditions, then any x that fails at least one condition is not a language.

**Formalization:**
```
∀x (¬(HasSyntax(x) ∧ RequiresParsing(x) ∧ HasLinearDecodingPressure(x) ∧ StableOntologyReference(x)) → ¬Language(x))
```



*Note: This is the standard move: a definition implies exclusions.*

---
### NEIAL-008: Example (Counterexample)

**Argument:** NotEverythingIsALanguage

> Counterexample: a chair can be interpreted as a sign (status, design, function), but it does not constitute a language system under the operational definition.

**Formalization:**
```
¬Language(Chair)
```

**Related Candidate:** A Chair


*Note: This separates semiotic availability (can signify) from linguistic structure (has syntax/parsing/serialized meaning).*

---
### NEIAL-009: Example (NonLanguageExample)

**Argument:** NotEverythingIsALanguage

> Non-language example: A Thunderstorm can be meaningful, but meaning here is not generated by an explicit syntax+parsing+serialization descriptor system.

**Formalization:**
```
¬Language(A Thunderstorm)
```

**Related Candidate:** A Thunderstorm

**Evidence:** `HasSyntax=False; RequiresParsing=True; HasLinearDecodingPressure=False; IsOngologyDescriptor=False; CanBeHeld=False; HasIdentity=True; DistanceFromConcept=1; Category=Physical event`

*Note: These are strong candidates for 'sign vehicles' rather than 'languages'.*

---
### NEIAL-010: Example (NonLanguageExample)

**Argument:** NotEverythingIsALanguage

> Non-language example: A Coffee Mug can be meaningful, but meaning here is not generated by an explicit syntax+parsing+serialization descriptor system.

**Formalization:**
```
¬Language(A Coffee Mug)
```

**Related Candidate:** A Coffee Mug

**Evidence:** `HasSyntax=False; RequiresParsing=False; HasLinearDecodingPressure=False; IsOngologyDescriptor=False; CanBeHeld=True; HasIdentity=True; DistanceFromConcept=1; Category=Physical Object`

*Note: These are strong candidates for 'sign vehicles' rather than 'languages'.*

---
### NEIAL-011: Example (NonLanguageExample)

**Argument:** NotEverythingIsALanguage

> Non-language example: The Mona Lisa can be meaningful, but meaning here is not generated by an explicit syntax+parsing+serialization descriptor system.

**Formalization:**
```
¬Language(The Mona Lisa)
```

**Related Candidate:** The Mona Lisa

**Evidence:** `HasSyntax=False; RequiresParsing=False; HasLinearDecodingPressure=False; IsOngologyDescriptor=True; CanBeHeld=True; HasIdentity=True; DistanceFromConcept=1; Category=Physical Object`

*Note: These are strong candidates for 'sign vehicles' rather than 'languages'.*

---
### NEIAL-012: Observation (FuzzyBoundary)

**Argument:** NotEverythingIsALanguage

> Fuzzy case: A Running App often contains embedded languages (code, UI grammars), but as an executing/interactive process it behaves like a dynamic system rather than a static serialized language artifact.

**Formalization:**
```
Borderline(A Running App): may contain ∃y Language(y) but ¬Language(A Running App) under static-serialization criteria
```

**Related Candidate:** A Running App


*Note: This is where traditional semiotics' 'anything is a sign' doesn’t neatly distinguish: (1) language-as-system vs (2) meaning-making interactive processes.*

---
### NEIAL-013: Observation (FuzzyBoundary)

**Argument:** NotEverythingIsALanguage

> Fuzzy case: Running Calculator App often contains embedded languages (code, UI grammars), but as an executing/interactive process it behaves like a dynamic system rather than a static serialized language artifact.

**Formalization:**
```
Borderline(Running Calculator App): may contain ∃y Language(y) but ¬Language(Running Calculator App) under static-serialization criteria
```

**Related Candidate:** Running Calculator App

**Evidence:** `HasSyntax=False; RequiresParsing=True; HasLinearDecodingPressure=False; IsOngologyDescriptor=False; CanBeHeld=False; HasIdentity=True; DistanceFromConcept=1; Category=Running Software`

*Note: This is where traditional semiotics' 'anything is a sign' doesn’t neatly distinguish: (1) language-as-system vs (2) meaning-making interactive processes.*

---
### NEIAL-014: Observation (FuzzyBoundary)

**Argument:** NotEverythingIsALanguage

> Fuzzy case: A Game of Fortnite often contains embedded languages (code, UI grammars), but as an executing/interactive process it behaves like a dynamic system rather than a static serialized language artifact.

**Formalization:**
```
Borderline(A Game of Fortnite): may contain ∃y Language(y) but ¬Language(A Game of Fortnite) under static-serialization criteria
```

**Related Candidate:** A Game of Fortnite

**Evidence:** `HasSyntax=False; RequiresParsing=True; HasLinearDecodingPressure=False; IsOngologyDescriptor=False; CanBeHeld=False; HasIdentity=True; DistanceFromConcept=1; Category=Running Software`

*Note: This is where traditional semiotics' 'anything is a sign' doesn’t neatly distinguish: (1) language-as-system vs (2) meaning-making interactive processes.*

---
### NEIAL-015: Definition (Refinement)

**Argument:** NotEverythingIsALanguage

> Refinement: distinguish LanguageSystem (syntax/parsing/serialization descriptor) from SemioticProcess (interactive/dynamic meaning production) and from SignVehicle (object/phenomenon used as a sign).

**Formalization:**
```
Kinds: LanguageSystem(x) | SemioticProcess(x) | SignVehicle(x)
```



*Note: This gives you a place to put running apps and games without forcing 'language' to swallow everything.*

---
### NEIAL-016: Conclusion (Conclusion)

**Argument:** NotEverythingIsALanguage

> Given a formalizable definition of language, not everything is a language; some things are better treated as sign vehicles or semiotic processes, with running applications as a key fuzzy region that benefits from explicit modeling.

**Formalization:**
```
Formalizable(Language) ∧ ∃x ¬Language(x) ⇒ ¬(EverythingIsALanguage)
```



*Note: This is the repo's thesis in one line.*

---

## Language Candidates

The following entities have been evaluated against the operational definition of "language" using testable predicates.

| Name | Category | Is Language? | HasSyntax | RequiresParsing | HasLinearDecodingPressure | StableOntologyReference | README |
|------|----------|--------------|-----------|-----------------|---------------------------|-------------------------|--------|
| Falsifier A | MISSING: Have you seen this Language? | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/falsifier-a/README.md) |
| Falsifier B | MISSING: Have you seen this Language? | No | ✗ | ✓ | ✗ | ✗ | - |
| Falsifier C | MISSING: Have you seen this Language? | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/falsifier-c/README.md) |
| English | Natural Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/english/README.md) |
| Airtable - Editing | Running Software | No | ✗ | ✗ | ✗ | ✗ | - |
| Spoken Words | Natural Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/spoken-words/README.md) |
| A Coffee Mug | Physical Object | No | ✗ | ✗ | ✗ | ✗ | - |
| A Game of Fortnite | Running Software | No | ✗ | ✓ | ✗ | ✗ | - |
| Sign Language | Natural Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/sign-language/README.md) |
| Python | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/python/README.md) |
| A Smartphone | Physical Object | No | ✗ | ✗ | ✓ | ✗ | - |
| A Running App  | Running Software | No | ✗ | ✓ | ✓ | ✗ | - |
| An XLSX Doc | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/an-xlsx-doc/README.md) |
| XLSX - Editing | Running Software | No | ✗ | ✗ | ✗ | ✗ | - |
| An DOCX Doc | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/an-docx-doc/README.md) |
| DOCX - Editing | Running Software | No | ✗ | ✗ | ✗ | ✗ | - |
| A CSV File | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/a-csv-file/README.md) |
| OWL/RDF/GraphQL/... generally | Natural Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/owl-rdf-graphql-generally/README.md) |
| A Thunderstorm | Physical event | No | ✗ | ✓ | ✗ | ✗ | - |
| A UML File | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/a-uml-file/README.md) |
| Binary Code | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/binary-code/README.md) |
| The Mona Lisa | Physical Object | No | ✗ | ✗ | ✗ | ✗ | - |
| Running Calculator App | Running Software | No | ✗ | ✓ | ✗ | ✗ | - |
| JavaScript | Formal Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/javascript/README.md) |
| French | Natural Language | Yes | ✓ | ✓ | ✓ | ✗ | [View](./execution-substratrates/french/README.md) |

### Predicate Legend

| Predicate | Description |
|-----------|-------------|
| **HasSyntax** | Has formal syntactic rules governing valid expressions |
| **RequiresParsing** | Understanding requires parsing/interpreting structured input |
| **HasLinearDecodingPressure** | Requires sequential/linear interpretation to extract meaning |
| **StableOntologyReference** | Provides stable references to concepts over time |

---

## Table Schemas

### Table: LanguageCandidates

> Table: LanguageCandidates

#### Schema

| Field | Type | Data Type | Nullable | Description |
|-------|------|-----------|----------|-------------|
| `LanguageCandidateId` | raw | string | No | - |
| `Name` | raw | string | Yes | Name of the language candidate being classified. |
| `Category` | raw | string | Yes | The general high level category of the candidate. |
| `FamilyFuedQuestion` | calculated | string | Yes | Question that 100 random people could be asked, family feud style. |
| `TopFamilyFeudAnswer` | calculated | boolean | Yes | The predicted answer as the top most popular answer among those in the family feud polling pool. |
| `ChosenLanguageCandidate` | raw | boolean | Yes | The test answer that is intended to match the Family Feud answer to be "correct". |
| `FamilyFeudMismatch` | calculated | string | Yes | If the family feud answer does not match the chosen language candidates status then this explains what did not match. t also flags (in english) mismatch where a candidate is marked as BOTH open AND closed world which does not make sense. |
| `HasSyntax` | raw | boolean | Yes | Does this language candidate have syntax and/or grammar? |
| `HasIdentity` | raw | boolean | Yes | Could this thing be assigned a guid, unique in the universe that would identify it globally?  Like a drivers license or social security number for a person. |
| `CanBeHeld` | raw | boolean | Yes | Is this candidate physical/material.  I.e. could it at least theoretically "be held"? |
| `HasGrammar` | calculated | boolean | Yes | Does this candidate have a Grammar?  Generally follows candidates that have syntax also have grammar. |
| `RequiresParsing` | raw | boolean | Yes | Is the knowledge/information encoded in a form that requires parsing before meaning can be extracted? |
| `ResolvesToAnAST` | raw | boolean | Yes | Is the knowledge/information encoded in a form that requires parsing before meaning can be extracted? |
| `HasLinearDecodingPressure` | raw | boolean | Yes | - |
| `IsStableOntologyReference` | raw | boolean | Yes | - |
| `IsLiveOntologyEditor` | raw | boolean | Yes | - |
| `DimensionalityWhileEditing` | raw | string | Yes | - |
| `IsOpenWorld` | raw | boolean | Yes | - |
| `IsClosedWorld` | raw | boolean | Yes | - |
| `IsOpenClosedWorldConflicted` | calculated | boolean | Yes | - |
| `DistanceFromConcept` | raw | integer | Yes | - |
| `IsDescriptionOf` | calculated | boolean | Yes | - |
| `RelationshipToConcept` | calculated | string | Yes | - |
| `ModelObjectFacilityLayer` | raw | string | Yes | - |
| `SortOrder` | raw | integer | Yes | - |

**Formula for `FamilyFuedQuestion`:**
```
="Is " & {{Name}} & " a language?"
```

**Formula for `TopFamilyFeudAnswer`:**
```
=AND(
  {{HasSyntax}},
  {{RequiresParsing}},
  {{IsDescriptionOf}},
  {{HasLinearDecodingPressure}},
  {{ResolvesToAnAST}},
  {{IsStableOntologyReference}},
  NOT({{CanBeHeld}}),
  NOT({{HasIdentity}})
)
```

**Formula for `FamilyFeudMismatch`:**
```
=IF(NOT({{TopFamilyFeudAnswer}} = {{ChosenLanguageCandidate}}),
  {{Name}} & " " & IF({{TopFamilyFeudAnswer}}, "Is", "Isn't") & " a Family Feud Language, but " & 
  IF({{ChosenLanguageCandidate}}, "Is", "Is Not") & " marked as a 'Language Candidate.'") & IF({{IsOpenClosedWorldConflicted}}, " - Open World vs. Closed World Conflict.")
```

**Formula for `HasGrammar`:**
```
={{HasSyntax}} = TRUE()
```

**Formula for `IsOpenClosedWorldConflicted`:**
```
=AND({{IsOpenWorld}}, {{IsClosedWorld}})
```

**Formula for `IsDescriptionOf`:**
```
={{DistanceFromConcept}} > 1
```

**Formula for `RelationshipToConcept`:**
```
=IF({{DistanceFromConcept}} = 1, "IsMirrorOf", "IsDescriptionOf")
```


#### Sample Data (25 records)

| Field | Value |
|-------|-------|
| `LanguageCandidateId` | falsifier-a |
| `Name` | Falsifier A |
| `TopFamilyFeudAnswer` | true |
| `IsStableOntologyReference` | true |
| `HasLinearDecodingPressure` | true |
| `RequiresParsing` | true |
| `HasSyntax` | true |
| `Category` | MISSING: Have you seen this Language? |
| `FamilyFeudMismatch` | Falsifier A Is a Family Feud Language, but Is Not marked as a 'Language Candidate.' |
| `SortOrder` | 0 |
| `FamilyFuedQuestion` | Is Falsifier A a language? |
| `RelationshipToConcept` | IsDescriptionOf |
| `DistanceFromConcept` | 2 |
| `HasGrammar` | true |
| `DimensionalityWhileEditing` | N/A |
| `IsDescriptionOf` | true |
| `ResolvesToAnAST` | true |
| `ModelObjectFacilityLayer` | M1 |
| `ChosenLanguageCandidate` | false |
| `HasIdentity` | false |
| `CanBeHeld` | false |
| `IsLiveOntologyEditor` | false |
| `IsOpenWorld` | false |
| `IsClosedWorld` | false |
| `IsOpenClosedWorldConflicted` | false |

---

### Table: IsEverythingALanguage

> Table: IsEverythingALanguage

#### Schema

| Field | Type | Data Type | Nullable | Description |
|-------|------|-----------|----------|-------------|
| `IsEverythingALanguageId` | raw | string | No | - |
| `Name` | raw | string | Yes | - |
| `ArgumentName` | raw | string | Yes | - |
| `ArgumentCategory` | raw | string | Yes | - |
| `StepType` | raw | string | Yes | - |
| `Statement` | raw | string | Yes | - |
| `Formalization` | raw | string | Yes | - |
| `RelatedCandidateName` | raw | string | Yes | - |
| `RelatedCandidateId` | raw | string | Yes | - |
| `EvidenceFromRulebook` | raw | string | Yes | - |
| `Notes` | raw | string | Yes | - |


#### Sample Data (16 records)

| Field | Value |
|-------|-------|
| `IsEverythingALanguageId` | neial-001 |
| `Name` | NEIAL-001 |
| `ArgumentName` | LanguageCanBeFormalized |
| `ArgumentCategory` | Definition |
| `StepType` | Motivation |
| `Statement` | To avoid the slogan 'Everything is a language', treat 'language' as a typed construct defined by testable properties (syntax, parsing, linear decoding pressure, and descriptor-role). |
| `Notes` | This keeps 'can be interpreted' separate from 'is a language system'. |
| `Formalization` |  |
| `RelatedCandidateName` |  |
| `RelatedCandidateId` |  |
| `EvidenceFromRulebook` |  |

---


## Metadata

**Summary:** Airtable export with schema-first type mapping: Schemas, Data, Relationships (FK links), Lookups (INDEX/MATCH), Aggregations (SUMIFS/COUNTIFS/Rollups), and Calculated fields (formulas) in Excel dialect. Field types are determined from Airtable's schema metadata FIRST (no coercion), with intelligent fallback to formula/data analysis only when schema is unavailable.

### Conversion Details

| Property | Value |
|----------|-------|
| Source Base ID | `appC8XTj95lubn6hz` |
| Table Count | 2 |
| Tool Version | 2.0.0 |
| Export Mode | schema_first_type_mapping |
| Field Type Mapping | checkbox→boolean, number→number/integer, multipleRecordLinks→relationship, multipleLookupValues→lookup, rollup→aggregation, count→aggregation, formula→calculated |

### Type Inference

- **Enabled:** true
- **Priority:** airtable_metadata (NO COERCION) → formula_analysis → reference_resolution → data_analysis (fallback only)
- **Airtable Type Mapping:** checkbox→boolean, singleLineText→string, multilineText→string, number→number/integer, datetime→datetime, singleSelect→string, email→string, url→string, phoneNumber→string
- **Data Coercion Hierarchy:** Only used as fallback when Airtable schema unavailable: datetime → number → integer → boolean → base64 → json → string
- **Nullable Support:** true
- **Error Value Handling:** #NUM!, #ERROR!, #N/A, #REF!, #DIV/0!, #VALUE!, #NAME? are treated as NULL

---

*Generated from effortless-rulebook.json*

