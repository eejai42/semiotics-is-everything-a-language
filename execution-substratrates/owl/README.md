# OWL Execution Substrate

OWL (Web Ontology Language) execution substrate for the Effortless Rulebook.

## Current Status

**Implemented and fully functional.** The compiler generates OWL TBox (ontology schema), ABox (data instances as Turtle), and SHACL-SPARQL rules from rulebook formulas. The test runner uses pyshacl to execute the rules and compute derived values.

Current test score: **100%** - All calculated fields pass.

## Running

```bash
# Generate OWL ontology and SHACL rules
python3 inject-into-owl.py

# Run tests (pyshacl executes SHACL-SPARQL rules)
./take-test.sh
```

## Architecture Overview

This substrate follows the same pattern as the binary substrate:

```
┌─────────────────────────────────────────────────────────────────┐
│                         INJECTOR                                │
│                    inject-into-owl.py                           │
│                                                                 │
│  Input:  effortless-rulebook.json                              │
│  Output: ontology.owl (TBox + ABox + SHACL/SWRL rules)         │
│                                                                 │
│  - 100% domain-agnostic (reads schema, never hardcodes fields) │
│  - Derives OWL axioms from formulas (like asm from formulas)   │
│  - Generates individuals from data rows                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      GENERATED ARTIFACTS                        │
│                                                                 │
│  ontology.owl          - TBox (classes, properties, axioms)    │
│  individuals.ttl       - ABox (data instances)                  │
│  rules.shacl.ttl       - SHACL-SPARQL rules (calculations)     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        TEST RUNNER                              │
│                       take-test.py                              │
│                                                                 │
│  - Scaffolding only (no hardcoded field names)                 │
│  - pip installs dependencies automatically                      │
│  - Loads ontology + rules                                       │
│  - Runs reasoner to compute values                              │
│  - Extracts results, writes test-answers.json                  │
└─────────────────────────────────────────────────────────────────┘
```

## Key Design Principles

### 1. Domain Agnosticism

The injector reads the rulebook schema and formulas generically:

```python
# inject-into-owl.py reads schema like this:
for column in rulebook["LanguageCandidates"]["schema"]:
    name = column["name"]           # e.g., "HasSyntax"
    datatype = column["datatype"]   # e.g., "Boolean"
    formula = column.get("formula") # e.g., "={{HasSyntax}}"

    # Generate property definition (no hardcoded field names)
    emit_property(name, datatype)

    if formula:
        # Parse formula, generate SHACL rule (like binary generates asm)
        emit_shacl_rule(name, parse_formula(formula))
```

The injector NEVER contains domain-specific words. All field names, categories, and formulas come from the rulebook.

### 2. Formula-Derived Rules (Like Binary Substrate)

Just as `inject-into-binary.py` compiles formulas to assembly:

```
Formula: IF({{DistanceFromConcept}} = 1, "IsMirrorOf", "IsDescriptionOf")
    ↓
Binary:  ARM64 assembly with cmp, b.eq, mov instructions
```

The OWL injector compiles the same formulas to SHACL-SPARQL rules:

```
Formula: IF({{DistanceFromConcept}} = 1, "IsMirrorOf", "IsDescriptionOf")
    ↓
SHACL:   sh:rule with SPARQL IF/BIND expressions
```

### 3. Scaffolding + Reasoner (Like Binary Pattern)

The binary substrate has:
- `inject-into-binary.py` → generates `erb_calc.dylib`
- `take-test.py` → scaffolding that calls the library via ctypes

The OWL substrate follows the same pattern:
- `inject-into-owl.py` → generates `ontology.owl` + `rules.shacl.ttl`
- `take-test.py` → scaffolding that runs the reasoner via pyshacl

```python
# take-test.py scaffolding (domain-agnostic)
def main():
    # Load ontology and rules (generated by injector)
    graph = load_ontology("ontology.owl")
    graph.parse("individuals.ttl")

    # Run SHACL reasoner - THIS does the computation
    # (like calling the dylib does computation in binary substrate)
    inferred = pyshacl.validate(graph, shacl_graph="rules.shacl.ttl",
                                 inference='rdfs', inplace=True)

    # Extract computed values from inferred graph
    for individual in get_individuals(graph):
        for calc_field in get_calculated_fields_from_rulebook():
            value = query_property(graph, individual, calc_field)
            record[calc_field] = value

    save_test_answers(records)
```

### 4. Determinism

To ensure deterministic output:
- Sort all triples by subject, predicate, object before serialization
- Use consistent URI generation: `erb:{table}_{row_index}`
- Use canonical Turtle serialization
- Seed any randomness (though none should be needed)

## Implementation Plan

### Phase 1: Dependencies

```bash
# take-test.sh will install automatically
pip install rdflib pyshacl --quiet
```

**Why pyshacl over owlready2:**
- SHACL-SPARQL rules are more expressive for formula translation
- No Java dependency (owlready2 bundles HermiT which needs Java)
- Pure Python, deterministic execution
- Better formula-to-rule mapping

### Phase 2: inject-into-owl.py

The injector generates three files:

#### 2a. ontology.owl (TBox - Schema)

```python
def generate_tbox(rulebook):
    """Generate OWL TBox from rulebook schema."""
    for table_name, table_def in rulebook.items():
        # Emit class for the table
        emit_class(table_name)

        for column in table_def["schema"]:
            # Emit property for each column
            name = column["name"]
            datatype = column["datatype"]
            emit_datatype_property(name, table_name, datatype)
```

#### 2b. individuals.ttl (ABox - Data)

```python
def generate_abox(rulebook):
    """Generate individuals from rulebook data."""
    for table_name, table_def in rulebook.items():
        for i, row in enumerate(table_def["data"]):
            uri = f"erb:{table_name}_{i}"
            emit_individual(uri, table_name)

            for column in table_def["schema"]:
                if not column.get("formula"):  # Only raw data
                    value = row.get(column["name"])
                    emit_property_value(uri, column["name"], value)
```

#### 2c. rules.shacl.ttl (Calculation Rules)

```python
def generate_shacl_rules(rulebook):
    """Compile formulas to SHACL-SPARQL rules."""
    for table_name, table_def in rulebook.items():
        for column in table_def["schema"]:
            formula = column.get("formula")
            if formula:
                # Parse formula to AST (reuse binary substrate parser)
                ast = parse_formula(formula)

                # Compile AST to SPARQL expression
                sparql_expr = compile_to_sparql(ast)

                # Emit SHACL rule
                emit_shacl_rule(column["name"], sparql_expr)
```

### Phase 3: Formula-to-SPARQL Compiler

Reuses the formula parser from binary substrate, but targets SPARQL:

```
Formula: FIND("language", LOWER({{Category}})) > 0
    ↓ parse
AST: BinaryOp(op='>',
       left=FuncCall('FIND', [LiteralString("language"),
                              FuncCall('LOWER', [FieldRef('Category')])]),
       right=LiteralInt(0))
    ↓ compile_to_sparql
SPARQL: (CONTAINS(LCASE(?category), "language"))
```

```
Formula: IF({{DistanceFromConcept}} = 1, "IsMirrorOf", "IsDescriptionOf")
    ↓ parse
AST: FuncCall('IF', [BinaryOp('=', FieldRef('DistanceFromConcept'), LiteralInt(1)),
                     LiteralString("IsMirrorOf"),
                     LiteralString("IsDescriptionOf")])
    ↓ compile_to_sparql
SPARQL: IF(?distance_from_concept = 1, "IsMirrorOf", "IsDescriptionOf")
```

### Phase 4: take-test.py (Scaffolding)

```python
#!/usr/bin/env python3
"""
Take Test - OWL Execution Substrate

Scaffolding that:
1. Loads generated ontology and SHACL rules
2. Runs pyshacl to compute derived values
3. Extracts results to test-answers.json

The computation happens in the reasoner, not hardcoded here.
"""
import subprocess
import sys

# Auto-install dependencies
subprocess.check_call([sys.executable, "-m", "pip", "install",
                       "rdflib", "pyshacl", "--quiet"])

from rdflib import Graph, Namespace
import pyshacl
import json
from pathlib import Path

# Add project root for shared imports
sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))
from orchestration.shared import load_rulebook

def main():
    script_dir = Path(__file__).resolve().parent

    # Load ontology + individuals
    graph = Graph()
    graph.parse(script_dir / "ontology.owl")
    graph.parse(script_dir / "individuals.ttl")

    # Load SHACL rules
    shacl_graph = Graph()
    shacl_graph.parse(script_dir / "rules.shacl.ttl")

    # Run reasoner - THIS DOES THE COMPUTATION
    # (equivalent to calling dylib functions in binary substrate)
    conforms, results_graph, results_text = pyshacl.validate(
        graph,
        shacl_graph=shacl_graph,
        inference='rdfs',
        inplace=True,  # Adds inferred triples to graph
        advanced=True  # Enable SHACL-SPARQL rules
    )

    # Extract computed values (domain-agnostic)
    rulebook = load_rulebook()
    records = extract_computed_values(graph, rulebook)

    # Save results
    test_file = script_dir / "test-answers.json"
    with open(test_file, "w") as f:
        json.dump(records, f, indent=2)

def extract_computed_values(graph, rulebook):
    """Extract all property values from inferred graph."""
    records = []
    erb = Namespace("http://example.org/erb#")

    for table_name, table_def in rulebook.items():
        for i, row in enumerate(table_def.get("data", [])):
            record = dict(row)  # Start with raw data
            uri = erb[f"{table_name}_{i}"]

            # Query each calculated field
            for column in table_def["schema"]:
                if column.get("formula"):
                    prop = erb[column["name"]]
                    value = graph.value(uri, prop)
                    if value is not None:
                        record[column["name"]] = convert_rdf_value(value)

            records.append(record)

    return records

if __name__ == "__main__":
    main()
```

## File Structure

```
owl/
├── inject-into-owl.py      # Injector (domain-agnostic)
├── inject-substrate.sh     # Orchestration wrapper
├── take-test.sh            # Test orchestration
├── take-test.py            # Test runner scaffolding
├── requirements.txt        # rdflib, pyshacl
│
├── ontology.owl            # Generated: TBox (schema)
├── individuals.ttl         # Generated: ABox (data)
├── rules.shacl.ttl         # Generated: SHACL calculation rules
│
├── test-answers.json       # Output: computed test results
└── README.md               # This file
```

## Comparison: Binary vs OWL Substrates

| Aspect | Binary Substrate | OWL Substrate |
|--------|------------------|---------------|
| **Injector** | inject-into-binary.py | inject-into-owl.py |
| **Formula target** | ARM64 assembly | SHACL-SPARQL rules |
| **Generated artifact** | erb_calc.dylib | ontology.owl + rules.shacl.ttl |
| **Test runner** | take-test.py + ctypes | take-test.py + pyshacl |
| **Computation** | Native code execution | SHACL reasoner |
| **Domain-agnostic** | Yes (reads formulas) | Yes (reads formulas) |
| **Deterministic** | Yes | Yes (sorted triples) |

## Generated Files

| File | Description |
|------|-------------|
| `ontology.owl` | **GENERATED** - OWL TBox (classes and properties) |
| `individuals.ttl` | **GENERATED** - RDF ABox (data instances) |
| `rules.shacl.ttl` | **GENERATED** - SHACL-SPARQL rules for calculations |
| `test-answers.json` | **GENERATED** - Test execution results for grading |
| `test-results.md` | **GENERATED** - Human-readable test report |

## Source Files (Not Cleaned)

| File | Description |
|------|-------------|
| `inject-into-owl.py` | The compiler: parses formulas and generates OWL/SHACL |
| `inject-substrate.sh` | Shell wrapper for orchestration |
| `take-test.py` | Test runner using pyshacl reasoner |
| `take-test.sh` | Shell wrapper for test runner |
| `requirements.txt` | Python dependencies |
| `README.md` | This documentation |

## Cleaning

To remove all generated files:

```bash
python3 inject-into-owl.py --clean
```

This will remove:
- `ontology.owl`
- `individuals.ttl`
- `rules.shacl.ttl`
- `test-answers.json`
- `test-results.md`

## Technology Background

**OWL (Web Ontology Language)** is a W3C standard for defining ontologies. Built on RDF and Description Logic, OWL enables automated reasoning about class membership.

**SHACL (Shapes Constraint Language)** is a W3C standard for validating RDF graphs and computing derived values via SHACL-SPARQL rules.

**pyshacl** is a pure Python SHACL validator that supports:
- SHACL Core constraints
- SHACL-SPARQL rules (for formula computation)
- RDFS inference

## Source

Generated from: `effortless-rulebook/effortless-rulebook.json`
